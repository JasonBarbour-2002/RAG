1
00:00:00,000 --> 00:00:08,000
 So, hello everyone. Welcome to the PC seminar. Today we have with us, Professor Amir Mowad

2
00:00:08,000 --> 00:00:13,240
 from American University of Beirut, and he'll be talking on the girth and parametrized complexity

3
00:00:13,240 --> 00:00:17,839
 of token sliding and token jumping. Thank you for joining us, Professor. Over to you

4
00:00:17,839 --> 00:00:18,839
 now.

5
00:00:18,839 --> 00:00:27,560
 Thank you, Prasivathai. Thank you for having me. It's a real pleasure to be here. So, alright,

6
00:00:27,560 --> 00:00:33,400
 let's jump right into it. So since I did not really know the audience too well, I made

7
00:00:33,400 --> 00:00:41,160
 the assumption that many of you maybe have not seen this area of combinatorial reconfiguration

8
00:00:41,160 --> 00:00:46,460
 problems. So I decided what I'm going to do is I'm going to give a gentle introduction

9
00:00:46,460 --> 00:00:53,280
 to the area just to show you how many exciting problems and open problems are there. And

10
00:00:53,280 --> 00:00:58,840
 then I will talk more about token jumping and token sliding, specifically what we know

11
00:00:58,840 --> 00:01:04,340
 about them, what we knew about them before we started working on this project, what we

12
00:01:04,340 --> 00:01:11,060
 managed to discover, and the tons of questions that remain to be answered. Right. And it's

13
00:01:11,060 --> 00:01:18,000
 a really, I mean, the questions are so nice to state, so easy to state, and they are accessible

14
00:01:18,000 --> 00:01:24,239
 really to researchers at any level, which is one of the reasons why I enjoy working

15
00:01:24,239 --> 00:01:31,879
 on these problems. So hopefully you'll get to enjoy them too. So before I start, I should

16
00:01:31,879 --> 00:01:37,980
 point out that this is joint work that started back in the combinatorial reconfiguration

17
00:01:37,980 --> 00:01:45,439
 workshop almost two years ago. And it's joint work with Valentin Bartier, Nicolas Bousquet,

18
00:01:45,439 --> 00:01:56,280
 and Karl Lomer, who is my master's student. All right. So the outline of the talk, it's

19
00:01:56,280 --> 00:02:02,439
 going to be in four sections. I will give a gentle introduction to combinatorial reconfiguration

20
00:02:02,439 --> 00:02:10,360
 because I know many of you might not have seen such problems. Then I will talk about

21
00:02:10,360 --> 00:02:15,680
 token jumping and token sliding, what we know about them in terms of classical complexity

22
00:02:15,680 --> 00:02:20,960
 or one-dimensional complexity. Then I'll talk about the parameterized complexity of these

23
00:02:20,960 --> 00:02:27,240
 two problems and what we know as of today as we speak, and what are the problems that

24
00:02:27,240 --> 00:02:32,200
 remain to be solved. And then the last part of the lecture is where I will put some of

25
00:02:32,200 --> 00:02:37,760
 the technical stuff to show you, to give you an idea about how we prove things when we

26
00:02:37,759 --> 00:02:42,719
 deal with such problems, and where are the difficulties, and what kind of techniques

27
00:02:42,719 --> 00:02:47,679
 have been developed. So I tried to keep the technical part as light as I could so that

28
00:02:47,679 --> 00:02:56,000
 really, I mean, I can focus on the big picture and the questions to be asked and answered.

29
00:02:56,000 --> 00:03:00,399
 So if you have any questions along the way, please feel free to interrupt me either in

30
00:03:00,400 --> 00:03:08,439
 the chat or by unmuting yourselves. So don't worry about leaving the questions till the

31
00:03:08,439 --> 00:03:14,040
 end. You can interrupt me whenever I say something that doesn't make sense. Hopefully, that won't

32
00:03:14,040 --> 00:03:21,840
 happen too often. All right. So what is combinatorial reconfiguration? So the best way, I think,

33
00:03:21,840 --> 00:03:28,540
 to introduce is with a familiar example, which is one-player games. And the most common one

34
00:03:28,539 --> 00:03:33,780
 that we use is the 15 puzzle game. So for those of you who don't know the 15 puzzle

35
00:03:33,780 --> 00:03:41,180
 games, so you're given like a four by four grid, and you have one empty square. And basically,

36
00:03:41,180 --> 00:03:45,459
 you have all the remaining 15 squares are numbered from one to 15, and they come in

37
00:03:45,459 --> 00:03:51,859
 some ordering. And your job is to basically move the squares around so that all the numbers

38
00:03:51,859 --> 00:03:58,359
 become ordered. So it's by row. So they have to be ordered this way. So if you notice in

39
00:03:58,360 --> 00:04:04,480
 this figure, the only problem is that 14 and 15 are reversed. But the only moves that

40
00:04:04,480 --> 00:04:12,440
 you're allowed to do is to basically move a number into the empty square. And basically,

41
00:04:12,440 --> 00:04:18,080
 you have to do a sequence of moves so that you get all of the numbers in order. And for

42
00:04:18,080 --> 00:04:25,720
 those of you who know this game, this example that I have on the slide is actually unsolvable.

43
00:04:25,720 --> 00:04:32,600
 There is no way you can flip the order of 14 and 15 in this puzzle. And I have a link

44
00:04:32,600 --> 00:04:37,520
 here if you want to actually play the puzzle online, which is pretty fun.

45
00:04:37,520 --> 00:04:43,960
 So why do I start my talk by talking about 15 puzzle? It's because it's really, I mean,

46
00:04:43,960 --> 00:04:50,520
 the way you solve the 15 puzzle tells you a lot about the area of combinatorial reconfiguration.

47
00:04:50,519 --> 00:04:57,439
 So the standard way we would think about the 15 puzzle is by looking at the state space

48
00:04:57,439 --> 00:05:02,459
 or what we call the reconfiguration graph of the 15 puzzle. So what does that graph

49
00:05:02,459 --> 00:05:10,039
 consist of? Well, we have one vertex or one node in this graph for each possible configuration

50
00:05:10,039 --> 00:05:16,120
 of the puzzle. So basically, each possible configuration, so it would be a possible permutation

51
00:05:16,120 --> 00:05:21,879
 of the 15 numbers in addition to where you're going to put the empty square. Each one of

52
00:05:21,879 --> 00:05:29,319
 those will be a vertex in the graph. And now we connect two vertices in that graph whenever

53
00:05:29,319 --> 00:05:34,439
 one can be reached from the other by a single move. And what do we mean here by a single

54
00:05:34,439 --> 00:05:40,800
 move where it's basically just moving a number into the empty square. So if you look at the

55
00:05:40,800 --> 00:05:47,240
 top node here in this graph, there are four possibilities that you can do in one move,

56
00:05:47,240 --> 00:05:51,960
 which we call a reconfiguration step, which is you can move nine into the empty square,

57
00:05:51,960 --> 00:05:58,319
 you can move three into the empty square, 12 or 15. And that gives us basically four

58
00:05:58,319 --> 00:06:05,199
 neighbors of that vertex in the graph. Okay, and we call this whole graph the reconfiguration

59
00:06:05,199 --> 00:06:09,840
 graph, or the state space, if you're more comfortable thinking about states, the states

60
00:06:09,840 --> 00:06:17,400
 of the game. So now given this graph, the reconfiguration graph, there are tons of very

61
00:06:17,400 --> 00:06:22,080
 interesting questions that you can ask about it. There are structural questions, and there

62
00:06:22,080 --> 00:06:27,920
 are algorithmic questions. And these are typically the types of questions that we're interested

63
00:06:27,920 --> 00:06:36,160
 in in this area of combinatorial reconfiguration. So a couple of examples of structural questions

64
00:06:36,160 --> 00:06:41,520
 would be, well, the simplest one would be how big is this reconfiguration graph, right?

65
00:06:41,520 --> 00:06:48,600
 How many vertices or how many edges? And that's usually not a very hard question to answer

66
00:06:48,600 --> 00:06:54,840
 in terms of upper and lower bounds. More interestingly, you could ask is this reconfiguration graph

67
00:06:54,840 --> 00:07:01,500
 connected, right? Or can I reach any state starting from any other state by a sequence

68
00:07:01,500 --> 00:07:08,259
 of legal moves? And as I told you before, for the 15 puzzle, the reconfiguration graph

69
00:07:08,259 --> 00:07:14,139
 is definitely not connected, because there was no way to reverse 14 and 15 in the previous

70
00:07:14,139 --> 00:07:19,699
 example that I showed you. And you can easily prove that, by the way. So when it's not connected,

71
00:07:19,699 --> 00:07:27,339
 another question would be how many components does it have? Is there some sort of nice structure

72
00:07:27,340 --> 00:07:33,260
 to the components of this graph? And then another question would be what is the diameter

73
00:07:33,260 --> 00:07:37,580
 of this reconfiguration graph or of each one of its components? And that's usually a very

74
00:07:37,580 --> 00:07:41,820
 important question to ask when you're dealing with one-player games, because this could

75
00:07:41,820 --> 00:07:48,860
 tell you what would be the worst possible shortest path to reach a target configuration

76
00:07:48,860 --> 00:07:53,980
 or to solve your game, to win your game, for example. And in the literature, this is sometimes

77
00:07:53,980 --> 00:08:00,580
 known as God's number, which would be the diameter of the reconfiguration graph. And

78
00:08:00,580 --> 00:08:06,860
 these are all very interesting structural questions to ask about this reconfiguration

79
00:08:06,860 --> 00:08:13,180
 graph. Now, on the algorithmic side or the computational side, there's the obvious question

80
00:08:13,180 --> 00:08:18,939
 of if I'm given a starting state and some ending state or target state, like in the

81
00:08:18,939 --> 00:08:23,779
 case of the puzzle game, that I am given some starting state and we know what the goal

82
00:08:23,779 --> 00:08:29,459
 state is. So here, one decision problem would be to answer the question whether it's possible

83
00:08:29,459 --> 00:08:36,059
 to get to the target state, starting from some initial state that is also given to me.

84
00:08:36,059 --> 00:08:39,940
 So you could decide to solve this problem either as a decision problem or as a search

85
00:08:39,940 --> 00:08:45,139
 problem, which would give you the actual sequence of steps that will take you from a state to

86
00:08:45,139 --> 00:08:54,620
 the target state. Other interesting computational problems, is it always possible to go from

87
00:08:54,620 --> 00:08:59,460
 one configuration to any other? And this is basically also related to the structural question

88
00:08:59,460 --> 00:09:07,460
 about connected components. And the last question that I will mention, which is also interesting,

89
00:09:07,460 --> 00:09:13,200
 is how fast can you go from one configuration to another? Meaning, can you do it in at most

90
00:09:13,200 --> 00:09:29,200
 case steps? There is a question. I should wait or no? Okay. All right. So think about

91
00:09:29,200 --> 00:09:34,840
 all of these questions that we paused using the simple 15 puzzle game. And now we're going

92
00:09:34,840 --> 00:09:42,280
 to look at a lot of other possible problems where the same reconfiguration graph can be

93
00:09:42,279 --> 00:09:47,039
 extracted and we can ask the same set of questions.

94
00:09:47,039 --> 00:09:52,000
 So all of you here are familiar with the k-SAT problem. So you're given a Boolean formula

95
00:09:52,000 --> 00:09:58,740
 and you want to know if you can satisfy this formula by assigning values to the variables.

96
00:09:58,740 --> 00:10:03,879
 And we know that this is NP-complete for k greater than or equal to 3. So now how can

97
00:10:03,879 --> 00:10:09,079
 you transform this into a reconfiguration problem? Well, it's very simple. So now you're

98
00:10:09,080 --> 00:10:15,920
 given a formula and you're given two satisfying assignments. So you can think of those satisfying

99
00:10:15,920 --> 00:10:22,759
 assignments as bit vectors. And so now the question that you can ask is, can I go from

100
00:10:22,759 --> 00:10:30,720
 the first satisfying assignment S to the next one by basically flipping one bit at a time

101
00:10:30,720 --> 00:10:37,600
 under the condition that I remain a satisfying assignment at all times? And notice that without

102
00:10:37,600 --> 00:10:44,180
 this condition, the problem is trivial. So you can basically just flip the bits however

103
00:10:44,180 --> 00:10:50,759
 you like and reach S from T or T from S. But once you add this constraint of you should

104
00:10:50,759 --> 00:10:56,580
 remain a satisfying assignment, the problem becomes way more interesting. And you can

105
00:10:56,580 --> 00:11:02,639
 think of this problem, again, as walking in the solution space of the given formula of

106
00:11:02,639 --> 00:11:07,439
 all the satisfying assignment of the formula F.

107
00:11:07,439 --> 00:11:16,360
 All right. So that's the SAT reconfiguration problem. Let's look at another example. Graph

108
00:11:16,360 --> 00:11:23,279
 coloring. We all know it. We all love it. You're given a graph and some integer k. And

109
00:11:23,279 --> 00:11:28,279
 you are asked whether you can properly k-color the graph G. And we know, again, that this

110
00:11:28,279 --> 00:11:34,039
 is NP-complete for k greater than or equal to 3. How do you transform that into a reconfiguration

111
00:11:34,039 --> 00:11:35,039
 problem?

112
00:11:35,039 --> 00:11:41,120
 Well, now you're given a graph. You're given two colorings of the graph, alpha and beta.

113
00:11:41,120 --> 00:11:47,839
 And the question is, can you recolor alpha to get to beta? But you need to recolor one

114
00:11:47,839 --> 00:11:55,639
 vertex at a time. And you need to remain a proper k-coloring throughout. Same idea, again,

115
00:11:55,639 --> 00:12:00,799
 leads us to this notion of the reconfiguration space, where we are looking at the k-colorings

116
00:12:00,799 --> 00:12:07,120
 of the graph and how they are connected under this adjacency relation that we define, which

117
00:12:07,120 --> 00:12:12,080
 is a single vertex recoloring.

118
00:12:12,080 --> 00:12:16,879
 The final example that I will mention, which will be basically what we will focus on in

119
00:12:16,879 --> 00:12:22,200
 the rest of the talk, is token placement, I call it. But as you will all guess, this

120
00:12:22,200 --> 00:12:27,800
 is the famous independent set problem. But we will look at it as a token placement problem,

121
00:12:27,800 --> 00:12:32,000
 because it will be more useful for the rest of the talk. So you're given a graph G and

122
00:12:32,000 --> 00:12:38,120
 an integer k. And the question is, can you place k tokens on your graph, k black tokens,

123
00:12:38,120 --> 00:12:40,960
 so that no two of these tokens share an edge?

124
00:12:40,960 --> 00:12:46,520
 And of course, we all know that this is an NP-complete problem. So how can you transform

125
00:12:46,520 --> 00:12:51,759
 this problem into a reconfiguration problem? Again, now I'm given a graph, two independent

126
00:12:51,799 --> 00:12:58,000
 sets of the graph, each of size k. And the question is, can I go from one independent

127
00:12:58,000 --> 00:13:05,840
 set to the other under what rule? So here, defining the rule for independent set, how

128
00:13:05,840 --> 00:13:11,080
 can I go between consecutive independent sets, becomes a little bit less obvious. And there

129
00:13:11,080 --> 00:13:16,519
 are two main strategies that people have attempted.

130
00:13:16,519 --> 00:13:21,559
 The first rule is what we call token jumping. So you are basically allowed to take any two

131
00:13:21,560 --> 00:13:27,880
 token on your graph and jump it to any other vertex on the graph, assuming that it doesn't

132
00:13:27,880 --> 00:13:34,920
 have a token and that you maintain an independent set at all times. So for example, in this

133
00:13:34,920 --> 00:13:40,920
 example that I have here, it would be perfectly okay to take this token here and jump it to

134
00:13:40,920 --> 00:13:51,080
 this vertex here. Or I could also take this token here and jump it to this vertex here.

135
00:13:51,400 --> 00:13:57,720
 No, actually that would violate the independence. So you can jump to any other vertex as long as

136
00:13:57,720 --> 00:14:04,280
 you maintain independence. And we call that the token jumping rule. The other rule is basically

137
00:14:04,280 --> 00:14:10,040
 token sliding. So in this case, we only allow a token to slide along edges of the graph.

138
00:14:11,480 --> 00:14:19,480
 So a token can only move to an adjacent vertex, assuming of course this does not violate

139
00:14:19,480 --> 00:14:24,920
 independence. So now we have two different reconfiguration graphs we can think about.

140
00:14:24,920 --> 00:14:28,840
 We can think about the reconfiguration graph under the token jumping adjacency,

141
00:14:29,480 --> 00:14:33,399
 and we can think about the reconfiguration graph under the token sliding adjacency.

142
00:14:34,519 --> 00:14:40,039
 And we're going to talk about these two different problems, because they do actually behave quite

143
00:14:40,039 --> 00:14:46,039
 differently, and they produce quite interesting results. Like the difference between the two,

144
00:14:46,039 --> 00:14:49,799
 we don't fully understand yet, but we kind of know that token sliding

145
00:14:50,599 --> 00:14:55,559
 can be harder than token jumping. But there's still a lot of questions to be answered.

146
00:14:58,599 --> 00:15:05,079
 All right, so some of you might be asking, why do we care about studying such problems? There's

147
00:15:05,079 --> 00:15:13,559
 a lot of motivations out there. I mean, sometimes I would say you don't need motivation. They're

148
00:15:13,560 --> 00:15:18,440
 interesting. There's a lot of open questions that we need to answer. But you can also think

149
00:15:18,440 --> 00:15:24,440
 about reconfiguration problems as another way of modeling real-world algorithmic problems,

150
00:15:24,440 --> 00:15:29,880
 because you usually never start from scratch. When you're trying to solve real-world problems,

151
00:15:29,880 --> 00:15:33,880
 you usually start from something, and you're trying to prove it, or make it better,

152
00:15:33,880 --> 00:15:41,560
 or change it to something more appropriate. Another very good application of studying

153
00:15:41,640 --> 00:15:45,160
 these problems is that they give you a better understanding of solution spaces,

154
00:15:45,800 --> 00:15:51,000
 which can be very important for other areas as well. And they have been used in statistical

155
00:15:51,000 --> 00:15:57,000
 physics, quantum computing, and in complexity theory, combinatorics, and robotics, and hopefully

156
00:15:57,000 --> 00:16:02,680
 many more applications to come. But what I would tell you is that there are so many very interesting

157
00:16:02,680 --> 00:16:08,520
 problems that are so easy to start thinking about without having too much background, which is why

158
00:16:08,519 --> 00:16:15,240
 I think this is a very nice area to start working on at any level in your research career.

159
00:16:19,319 --> 00:16:23,159
 All right. So I'll take a break here and take questions if there are any.

160
00:16:23,159 --> 00:16:29,960
 And then we will dive into the token jumping and token sliding problems, what we know about them

161
00:16:30,679 --> 00:16:35,559
 in terms of classical complexity, and what was basically the starting point for the project that

162
00:16:35,560 --> 00:16:41,880
 led us to this paper. Any questions at this point?

163
00:16:46,040 --> 00:16:52,040
 I apologize for the small context, which I am interrupting here. So this is just to announce

164
00:16:52,040 --> 00:16:58,040
 for the PC301 workshop that will be happening in December end. And this will be slightly different

165
00:16:58,040 --> 00:17:03,080
 from the previous two workshops. First major difference, this will be online. Second is

166
00:17:03,800 --> 00:17:11,880
 some advanced topics will be discussed. So anyone who intends to explore somewhat more complex

167
00:17:11,880 --> 00:17:18,519
 topics in parameterized algorithms is invited to have a check. They can look at the website that

168
00:17:18,519 --> 00:17:23,160
 has been shared on the chat. And if you wish, you can register simply by filling a form that is

169
00:17:24,440 --> 00:17:30,519
 linked at the bottom of the web page. So just to inform you all about it, and sorry for the

170
00:17:30,519 --> 00:17:42,039
 interruption for person. All right. All right. So let's start talking about token jumping,

171
00:17:42,039 --> 00:17:48,119
 token sliding, and a little bit about classical complexity. So I know everybody here knows about

172
00:17:48,119 --> 00:17:53,799
 P and NP, so I'm not going to talk about this. Some of you might not be familiar with the PSpace

173
00:17:53,799 --> 00:18:00,359
 class. So just a quick note, that's as much as you will need to know for this talk is that PSpace is

174
00:18:00,360 --> 00:18:05,880
 the set of all decision problems that can be solved using a polynomial amount of space.

175
00:18:06,840 --> 00:18:12,760
 And the reason why I mentioned this class, it's because many, many, many, many reconfiguration

176
00:18:12,760 --> 00:18:20,200
 problem actually are PSpace complete. Okay. And so what we know the standard inclusion is we know

177
00:18:20,200 --> 00:18:26,520
 that P is contained in NP, which is contained in PSpace, but a very useful thing about PSpace is

178
00:18:26,519 --> 00:18:33,400
 that Savage proved that it's equal to NPSpace. So polynomial space and non-deterministic

179
00:18:33,400 --> 00:18:40,519
 polynomial space are the same class, basically. And that's extremely useful when you start to

180
00:18:40,519 --> 00:18:44,440
 think about reconfiguration problems, because if you think of a reconfiguration problem where

181
00:18:44,440 --> 00:18:52,279
 you're given some state and you want to reach the other one, so basically you can solve that easily

182
00:18:52,279 --> 00:18:58,839
 in non-deterministic polynomial space, which basically implies that they are in PSpace.

183
00:19:00,759 --> 00:19:05,480
 But actually you can show a lot more than that. You can show that many, really many

184
00:19:05,480 --> 00:19:10,920
 reconfiguration problems are actually PSpace complete, which is not surprising, right?

185
00:19:10,920 --> 00:19:16,359
 The fact that many of these reconfiguration problems are PSpace complete is not very

186
00:19:16,440 --> 00:19:22,920
 surprising, right? And them not being in NP is because they don't always have

187
00:19:22,920 --> 00:19:28,680
 polynomial size certificates, which also makes sense because sometimes the number of steps that

188
00:19:28,680 --> 00:19:33,800
 you need to take to go from one configuration to the other might very well be exponential

189
00:19:33,800 --> 00:19:38,840
 in the graph size. But there are also some extremely surprising results,

190
00:19:38,840 --> 00:19:42,840
 and these are some of the results, some of my favorite results in the area.

191
00:19:43,799 --> 00:19:49,559
 So for example, you all know that coloring is NP-complete even for k equals three.

192
00:19:50,279 --> 00:19:56,599
 However, it turns out that if you try to solve the recoloring problem for k equals three,

193
00:19:57,319 --> 00:20:03,240
 it's actually polynomial time solvable. So if I give you two, three colorings of a graph and I ask

194
00:20:03,240 --> 00:20:10,119
 you, is there a path between them that recolors one vertex at a time and never is and is always

195
00:20:10,200 --> 00:20:14,840
 a valid three coloring, then this problem can be solved in polynomial time.

196
00:20:14,840 --> 00:20:19,560
 And the recoloring problem only becomes PSpace complete for k equal four and more,

197
00:20:21,960 --> 00:20:27,640
 right? So that's the first surprising result. Another very surprising result is that

198
00:20:28,520 --> 00:20:34,840
 as you're all FPT experts here, I know that you're all familiar with the fact that usually

199
00:20:34,840 --> 00:20:39,000
 when we study problems on graphs of bounded bucket width, path width, tree width,

200
00:20:39,720 --> 00:20:47,799
 they tend to become easier. It turns out that that's not really the case for reconfiguration

201
00:20:47,799 --> 00:20:52,200
 problems, at least for token sliding and jumping, which is the two problems that are related to

202
00:20:52,200 --> 00:20:58,200
 independent sets. It turns out that those two problems remain PSpace complete even if you have

203
00:20:58,200 --> 00:21:04,440
 a graph of constant tree width or path width or even bucket width. So a very, very, very simple

204
00:21:04,440 --> 00:21:13,320
 graph structure, still the problem remains hard. All right. And finally, the last

205
00:21:14,360 --> 00:21:21,240
 theorem that I also like a lot shows you basically that sliding and jumping behave differently.

206
00:21:21,880 --> 00:21:29,080
 And it was shown that if you restrict yourself to bipartite graphs, where we know that max

207
00:21:29,080 --> 00:21:34,200
 independent sets can be solved in polynomial time, if you restrict yourself to those graphs,

208
00:21:34,200 --> 00:21:42,519
 it turns out that token jumping is NP-complete, whereas token sliding is PSpace complete,

209
00:21:45,319 --> 00:21:50,920
 which is a strange difference between the behavior of those two problems.

210
00:21:54,279 --> 00:22:02,519
 All right. So in fact, we know a lot more about token sliding and token jumping. These

211
00:22:03,079 --> 00:22:08,039
 problems have been at the heart of the area of combinatorial reconfiguration. They have been

212
00:22:08,039 --> 00:22:14,519
 studied so much, and we know so much about them, at least in terms of standard or classical

213
00:22:14,519 --> 00:22:22,200
 complexity. So some of the important results for our paper that we're going to focus on

214
00:22:23,879 --> 00:22:30,519
 is this result. So that's going to be the starting point of the results that we will discuss next

215
00:22:30,519 --> 00:22:35,079
 when we move to parameterized complexity. So the fact that token sliding and token jumping

216
00:22:36,599 --> 00:22:41,160
 are PSpace complete and then NP-complete respectively on bipartite graphs was the

217
00:22:41,160 --> 00:22:45,559
 starting point of our next paper. But there are some very interesting results here that

218
00:22:45,559 --> 00:22:50,519
 are also worth mentioning. So for example, for even whole-field graphs, we know how to

219
00:22:50,519 --> 00:22:57,319
 solve token jumping in polynomial time, but the complexity of independent set even remains open

220
00:22:57,319 --> 00:23:03,480
 on this class of graphs. And the complexity of token sliding also remains open. So we don't know

221
00:23:03,480 --> 00:23:10,279
 how to check if given two independent sets, I can slide one to the other. Can you answer that

222
00:23:10,279 --> 00:23:17,960
 question in polynomial time for even whole-free graphs? For split graphs and chordal graphs,

223
00:23:17,960 --> 00:23:22,839
 they also behave extremely differently, token sliding and token jumping, right? So they are

224
00:23:22,839 --> 00:23:28,519
 token sliding is PSpace complete on split graphs and chordal graphs while token jumping

225
00:23:28,519 --> 00:23:35,399
 is polynomial time. And that is some of the reasons why we feel that token sliding

226
00:23:35,399 --> 00:23:39,399
 is harder usually than token jumping, but it's not always the case.

227
00:23:43,399 --> 00:23:48,439
 All right. So that's it for classical complexity.

228
00:23:48,440 --> 00:23:55,240
 So now let's move on to parameterized complexity. And let's basically think

229
00:23:55,240 --> 00:23:59,880
 about how you can parameterize those two problems, token jumping and token sliding.

230
00:24:01,240 --> 00:24:07,480
 So the obvious parameter would be the number of tokens, right? So one of the obvious parameters

231
00:24:07,480 --> 00:24:13,799
 would be the number of tokens. And we're going to denote that by k. Another parameter would be

232
00:24:13,799 --> 00:24:18,839
 the length of the sequence. Like how many steps does it take to go from one independent set

233
00:24:19,399 --> 00:24:25,159
 to the other? You can also obviously parameterize by tree width or path width or any combination of

234
00:24:25,159 --> 00:24:33,639
 the above. When we started working on this problem, our initial aim was to basically

235
00:24:33,639 --> 00:24:38,119
 study the parameterized complexity of token sliding and token jumping on bipartite graphs

236
00:24:38,920 --> 00:24:45,880
 using the parameter k number of tokens, right? Because remember, we saw that token sliding is

237
00:24:45,880 --> 00:24:52,040
 PSPACE complete on bipartite graphs and token jumping is NP complete. So we were interested

238
00:24:52,040 --> 00:24:58,760
 to see if basically this is going to give us W1 hardness for token sliding and FPTness for token

239
00:24:58,760 --> 00:25:05,400
 jumping. At least that was the initial hope. That's why we started working on this project.

240
00:25:06,120 --> 00:25:10,840
 We weren't able to answer the two questions. So we were able to answer

241
00:25:10,840 --> 00:25:19,080
 one side of the question, which is we were able to show that on bipartite graphs, token sliding

242
00:25:19,080 --> 00:25:25,160
 is in fact W1 hard. So token sliding parameterized by the number of tokens

243
00:25:25,800 --> 00:25:31,960
 on bipartite graphs is W1 hard. We were not able to answer the question for token jumping.

244
00:25:32,920 --> 00:25:40,519
 So that is still an open question. So having answered that question and failed on the next

245
00:25:40,519 --> 00:25:45,240
 question, we started thinking about ways to basically simplify a little bit some of these

246
00:25:45,240 --> 00:25:51,799
 questions. So the next thing we asked ourselves, so there are two directions where you can try

247
00:25:52,360 --> 00:26:00,039
 and simplify. So the next thing we asked ourselves was, okay, so from bipartite graphs,

248
00:26:00,359 --> 00:26:07,799
 how can I go to other classes of graphs and see where token jumping becomes hard or easy?

249
00:26:08,599 --> 00:26:14,359
 And it turned out that if you basically exclude only C4 from your graph,

250
00:26:16,359 --> 00:26:25,159
 because in bipartite graphs, you're excluding all odd cycles. And we started thinking about what

251
00:26:25,160 --> 00:26:31,240
 kinds of cycles affect the behavior of those problems? So the first question was, what about

252
00:26:31,240 --> 00:26:36,759
 C4 free graphs? And it turned out that both problems remain W1 hard on C4 free graphs.

253
00:26:38,120 --> 00:26:45,800
 Now, if you exclude C3 and C4, it turns out that token jumping becomes FPG, has an order

254
00:26:45,800 --> 00:26:52,040
 k squared kernel. But for token sliding, we were not able to determine the complexity.

255
00:26:52,039 --> 00:27:01,240
 Now, if you go to the other side of that, so what if we enforce both bipartite tightness

256
00:27:01,240 --> 00:27:09,639
 as well as C4 freeness? So in that case, we were able to show that both problems became FPG.

257
00:27:13,879 --> 00:27:18,519
 Okay, and basically the bipartite bounded degree graphs was just a stepping stone

258
00:27:18,519 --> 00:27:21,160
 to get to the bipartite C4 free graph result.

259
00:27:23,240 --> 00:27:29,160
 So let me repeat that maybe slightly more clearly. So after basically answering the first

260
00:27:29,160 --> 00:27:34,599
 question, which was bipartite graphs, we were able to show that token sliding was W1 hard,

261
00:27:34,599 --> 00:27:37,799
 but we were not able to determine the complexity of token jumping.

262
00:27:38,599 --> 00:27:44,759
 So then we went to C4 free graphs, and we were able to show that both problems are actually W1

263
00:27:44,759 --> 00:27:50,599
 hard. Then if we added one more constraint, which was C3 C4 free graphs,

264
00:27:50,599 --> 00:27:55,319
 we got FPGness for token jumping, but it remained open for token sliding.

265
00:27:56,440 --> 00:28:02,920
 And on the other side of the spectrum, so if we keep bipartite and enforce the C4 freeness,

266
00:28:02,920 --> 00:28:05,240
 we get FPG for both problems.

267
00:28:05,559 --> 00:28:16,279
 And as a side note, this blue result is not part of our paper. This was known prior to our paper.

268
00:28:20,440 --> 00:28:23,720
 So any questions about the results?

269
00:28:36,039 --> 00:28:40,839
 No questions. All right, cool.

270
00:28:44,359 --> 00:28:53,400
 So lots of open problems. The first and obvious one is, is token jumping FPG parameterized by

271
00:28:53,400 --> 00:28:59,160
 k on bipartite graphs? And that's really, I mean, that was the initial question that we set out to

272
00:28:59,240 --> 00:29:11,560
 answer and couldn't. So that remains open. And so I will not be going over the hardness reduction

273
00:29:11,560 --> 00:29:16,920
 for token sliding on bipartite graphs, because it's quite technical. I don't feel a talk is the

274
00:29:16,920 --> 00:29:26,440
 right place to go over it. But if you go over the reduction, you will see that the two problems

275
00:29:26,440 --> 00:29:31,880
 really behave differently. And there doesn't seem to be a chance to basically make the same

276
00:29:31,880 --> 00:29:38,519
 type of reduction work for token jumping. So the second interesting open question is,

277
00:29:38,519 --> 00:29:43,559
 how about token jumping parameterized by k on triangle-free graphs? That's basically

278
00:29:44,360 --> 00:29:51,480
 even more general than question one. And the reason why I mentioned this question separately

279
00:29:51,480 --> 00:29:58,360
 is because almost every reduction that I know of includes large cliques. So you need to use

280
00:29:58,360 --> 00:30:05,160
 large cliques in your reductions. So how about if we don't allow triangles and large cliques?

281
00:30:05,160 --> 00:30:12,519
 So can we then say something about the problem? So that's for token jumping. Now, when you go

282
00:30:12,519 --> 00:30:20,279
 to token sliding, so the open problem is, what happens for token sliding on graphs of girth

283
00:30:20,279 --> 00:30:27,720
 at least 5? So if they are C3, C4 free. Or you can even make that a bit weaker and ask for any

284
00:30:28,440 --> 00:30:36,039
 girth of at least p, for some constant p. And for all of these questions, of course,

285
00:30:36,039 --> 00:30:44,119
 polynomial kernels would be interesting as well. Because in our case, we do get polynomial kernels

286
00:30:44,120 --> 00:30:53,400
 for the FPT design. The polynomials are not great, but polynomial regardless.

287
00:30:56,680 --> 00:31:03,720
 All right. So in the rest of the talk, I will try to cover some of the technical stuff.

288
00:31:03,720 --> 00:31:08,040
 And as promised, I will try to keep it as light as possible so that I can give you

289
00:31:08,200 --> 00:31:15,480
 some of a lot of the intuition and techniques that are used in this paper and that are generally

290
00:31:15,480 --> 00:31:21,240
 used when dealing with reconfiguration problems. So the first result that we will go over is this

291
00:31:21,240 --> 00:31:28,200
 W hardness on C4 free graphs for both token sliding and token jumping. It's the same reduction,

292
00:31:28,200 --> 00:31:35,720
 and you will get both results because we will be using maximum independent sets.

293
00:31:36,440 --> 00:31:43,160
 So if you're trying to basically do token sliding from one maximum independent set to the other

294
00:31:43,799 --> 00:31:48,920
 or token jumping, these two rules become equivalent. Jumping becomes equivalent to sliding.

295
00:31:49,480 --> 00:31:54,360
 So when you're dealing with maximum independent sets, these two basically rules are the same.

296
00:31:55,319 --> 00:31:59,480
 And that's what we're going to do. But what we're going to prove actually is a stronger

297
00:31:59,480 --> 00:32:04,839
 theorem. What we're going to prove is the following theorem. If you take any p greater

298
00:32:04,840 --> 00:32:15,240
 than or equal to 4, then both problems are W-hard on C4, C5, dot, dot, dot up to CP free graphs,

299
00:32:16,920 --> 00:32:22,760
 which implies, of course, C4 free graphs. But you can basically exclude

300
00:32:23,800 --> 00:32:30,680
 any cycles from C4 up to CP for constant p, and the problems will remain W-hard.

301
00:32:34,840 --> 00:32:40,760
 So how do we prove this result? In fact, we use a known reduction

302
00:32:41,400 --> 00:32:49,560
 from a problem known as grid tiling, which is a W-1-hard problem. And grid tiling is reduced

303
00:32:49,560 --> 00:32:58,120
 to the independent set problem on C4 up to CP free graphs. And that reduction was used to show

304
00:32:58,120 --> 00:33:05,320
 that independent set remains W-1-hard if you exclude C4 up to CP for any constant p.

305
00:33:06,520 --> 00:33:12,600
 But what is interesting and useful in that reduction is the graph that is obtained

306
00:33:13,640 --> 00:33:16,760
 from the reduction. So the graph that is obtained from the reduction

307
00:33:17,480 --> 00:33:23,560
 has three properties that are going to be useful to us. The first property is that you can partition

308
00:33:23,559 --> 00:33:32,200
 the graph into basically 8k squared into p plus 1 cliques. So you have a bunch of cliques,

309
00:33:32,200 --> 00:33:36,919
 each of size n, and all of the edges basically are between the cliques.

310
00:33:38,919 --> 00:33:43,480
 But that's it. That's it. That's the whole of the graph. It's a bunch of cliques

311
00:33:43,480 --> 00:33:49,559
 and edges between them. Of course, the more important property as well here is that

312
00:33:49,559 --> 00:33:57,159
 this graph is going to be C4 up to CP free. It will not have any of those cycles as an

313
00:33:57,159 --> 00:34:04,679
 induced subgraph. And it's an equivalent instance to the grid tiling instance.

314
00:34:04,679 --> 00:34:11,239
 And that basically gives you W-1-hardness of independent set on this class of graphs.

315
00:34:13,320 --> 00:34:19,239
 So notice in this case that an independent set of size 8k squared into p plus 1 will

316
00:34:19,240 --> 00:34:23,560
 have to be a maximum independent set because that's how many cliques we get in the resulting

317
00:34:23,560 --> 00:34:29,080
 graph. And that's basically the sizes that we will be working with, more or less up to some

318
00:34:29,080 --> 00:34:37,320
 modifications. But this will allow us to basically conclude that both sliding and jumping are hard

319
00:34:37,320 --> 00:34:47,800
 on this class of graphs. So how do we use this for showing hardness of token sliding and token

320
00:34:47,800 --> 00:34:52,280
 jumping? And let's focus on token sliding for now because it's going to be the same anyway.

321
00:34:53,000 --> 00:34:57,320
 So we have those cliques and some edges that go between the cliques.

322
00:34:57,960 --> 00:35:05,640
 So the first attempt would be as follows. We will add a universal vertex to each one of the cliques

323
00:35:05,640 --> 00:35:09,400
 and we will call this the starting set or the starting independent set.

324
00:35:10,440 --> 00:35:15,160
 And then we add another universal vertex to each one of the cliques and call this the target

325
00:35:15,239 --> 00:35:20,839
 independent set. And now basically we have our instance of token sliding. We want to slide

326
00:35:20,839 --> 00:35:30,199
 everybody in s down to t. So notice that this is useful because we don't introduce any of the

327
00:35:30,199 --> 00:35:38,119
 forbidden cycles. So we are still fine. And if we could guarantee that all of the tokens will be

328
00:35:38,679 --> 00:35:45,239
 on the cliques simultaneously, then this will imply an independent set in the original graph,

329
00:35:46,119 --> 00:35:51,400
 which concludes our proof. But unfortunately, in this case, we definitely cannot conclude that

330
00:35:51,960 --> 00:35:59,319
 because each red token can slide independently here and then here, and then the next one can

331
00:35:59,319 --> 00:36:07,079
 follow, et cetera, et cetera, et cetera. So you need some way of forbidding these tokens

332
00:36:07,079 --> 00:36:14,440
 to behave freely. We want to ensure that they will all be inside the cliques simultaneously

333
00:36:14,440 --> 00:36:19,799
 and we will be done. And notice that we're going to have 8k squared and 2p plus one tokens, right?

334
00:36:19,799 --> 00:36:27,799
 One for each clique and two universal vertices for each clique. So how do we fix this simultaneity

335
00:36:27,799 --> 00:36:35,799
 issue? Well, here's how we can do it. So instead of simply adding universal vertices,

336
00:36:36,519 --> 00:36:41,000
 we're also going to add an edge between every two universal vertices of a clique.

337
00:36:41,640 --> 00:36:47,160
 And then we're going to add something that we call a switch. And in this case, it's a simple edge.

338
00:36:48,120 --> 00:36:55,000
 And the red token here needs to go to the blue position, right? So now we have one extra

339
00:36:55,800 --> 00:37:04,840
 token inside our graph. But now notice what happens. If any red token wants to come to the

340
00:37:04,840 --> 00:37:12,519
 blue position, then this red token needs to be moved to this position before. And if you move

341
00:37:12,519 --> 00:37:17,720
 that token up to the blue position, then you can no longer have any of the red tokens on the

342
00:37:17,720 --> 00:37:23,720
 universal vertices, which means that they will all have to be simultaneously inside the cliques.

343
00:37:25,240 --> 00:37:32,280
 And now we get the behavior that we want. So now we can guarantee that if there is a sequence that

344
00:37:32,280 --> 00:37:40,360
 takes the red tokens to the blue position, then some way along that sequence, the tokens are all

345
00:37:40,360 --> 00:37:45,560
 going to be within the cliques. Unfortunately, what happened here is we might have introduced

346
00:37:45,560 --> 00:37:52,600
 some of the forbidden cycles. We can no longer guarantee that this is C4 up to CP3.

347
00:37:54,200 --> 00:37:58,760
 So what you can do in this case to solve this problem, and I'm not going to go into the details,

348
00:37:59,400 --> 00:38:05,960
 but the intuition should be pretty clear, is that you can subdivide those edges, make them

349
00:38:05,960 --> 00:38:11,080
 long enough so that you don't introduce any forbidden cycles, and add appropriate tokens

350
00:38:11,080 --> 00:38:18,760
 inside of them to get the same behavior. Because notice that the number of such edges is bounded

351
00:38:18,760 --> 00:38:28,520
 by a function of K, by a function of, yes, K and P in this case. So you can make these edges,

352
00:38:29,080 --> 00:38:35,000
 subdivide them as many times as needed, add as many tokens as needed to maintain all the

353
00:38:35,000 --> 00:38:39,320
 properties that we need, and to maintain that we're going from one maximum independent set

354
00:38:39,320 --> 00:38:45,480
 to the other, which will give you W1 hardness for both token sliding as well as token jumping.

355
00:38:48,760 --> 00:38:55,240
 All right. Questions.

356
00:39:07,640 --> 00:39:10,680
 No questions. All right. So let's keep going.

357
00:39:13,640 --> 00:39:17,640
 So now I'm going to talk about some positive results.

358
00:39:19,000 --> 00:39:27,480
 So the result that I'm going to talk about is this one here. So I'm going to show you that

359
00:39:27,480 --> 00:39:36,440
 on C3, C4-free graphs, token jumping is actually FPG and has a quadratic kernel. But again,

360
00:39:36,440 --> 00:39:41,800
 what we will show is a stronger result. So what we will show is the following theorem.

361
00:39:42,680 --> 00:39:50,760
 What we will show can be summarized as follows. So if you look at any graph

362
00:39:52,840 --> 00:39:57,960
 or at any instance of the token jumping problem. So remember, an instance of token jumping has the

363
00:39:57,960 --> 00:40:02,840
 input graph, the starting set, the target set, and K as the number of tokens.

364
00:40:03,160 --> 00:40:13,640
 So let me try and draw something here. So if you look at your graph, you can kind of decompose it

365
00:40:13,640 --> 00:40:20,760
 into something which is more or less as follows. So you have S, you have T, their intersection

366
00:40:20,760 --> 00:40:29,559
 need not be empty. And then you have the neighborhood of S union T. And then you have

367
00:40:29,559 --> 00:40:37,719
 the rest of the graph. So we're going to call the rest of the graph H, and we're going to call

368
00:40:38,279 --> 00:40:46,279
 the closed neighborhood of S union T, or if you will, this yellow part here, we call that J.

369
00:40:47,719 --> 00:40:53,480
 So we can think of our problem of our graph as being decomposed into those two areas, H and J.

370
00:40:53,559 --> 00:41:04,519
 Okay, so the theorem states the following. If H is epsilon sparse, where epsilon sparse means

371
00:41:04,519 --> 00:41:11,000
 that the number of edges is at most n squared minus epsilon, positive epsilon. So if H is

372
00:41:11,000 --> 00:41:21,320
 epsilon sparse and J is C3, C4 free, then the problem admits a kernel which is that big,

373
00:41:21,320 --> 00:41:24,440
 K squared plus K into one plus one over epsilon.

374
00:41:25,240 --> 00:41:34,680
 So notice now that we only need that H is epsilon sparse, and we only require C3, C4

375
00:41:34,680 --> 00:41:41,400
 freeness inside J, which is S union T closed neighborhood, closed neighborhood of S union T.

376
00:41:42,280 --> 00:41:53,000
 And this idea is actually is not a new idea. So this idea is, okay, I had the drawing here,

377
00:41:53,000 --> 00:41:59,720
 I should have used it. So the idea comes from, has been used before, and it's what we call the

378
00:41:59,720 --> 00:42:04,519
 buffer technique for the token jumping problem. And the intuition behind the buffer technique is

379
00:42:04,519 --> 00:42:12,039
 very simple. So if I have S union T, but somewhere in the graph, which is not in the closed

380
00:42:12,039 --> 00:42:18,679
 neighborhood of S union T, I have a K-sized independent set, then you are done, right?

381
00:42:18,679 --> 00:42:24,599
 If I have a K-sized independent set in H, then you're done. You can basically

382
00:42:25,159 --> 00:42:31,400
 take all the tokens on S, jump them into those independent yellow vertices in H,

383
00:42:31,400 --> 00:42:37,559
 and then jump them back to T. So in some sense, when H has a large independent set,

384
00:42:38,119 --> 00:42:44,440
 that's the easy case, right? You're done. If you can find a large enough independent set in H,

385
00:42:44,440 --> 00:42:50,200
 you're done. And that's what we call the buffer technique, because it's been also used to show

386
00:42:50,200 --> 00:42:57,400
 that the problem is FPT on planar graphs, for example, or K3 J-free graphs, so graphs without

387
00:42:57,400 --> 00:43:05,960
 large biplanes. So it's a well-known technique. All right.

388
00:43:09,079 --> 00:43:12,840
 So what do we show? So we're going to use the buffer technique,

389
00:43:12,840 --> 00:43:14,599
 and we're going to combine it with something else.

390
00:43:17,240 --> 00:43:23,720
 So we show that you have a yes instance whenever one of those two conditions is true.

391
00:43:23,720 --> 00:43:33,000
 The first condition is that H is epsilon sparse and contains more than this many vertices.

392
00:43:34,520 --> 00:43:41,000
 And this is relatively easy. When you contain this many vertices and you are epsilon sparse,

393
00:43:41,000 --> 00:43:45,560
 then you will have a K-sized independent set. And that's basically the buffer technique.

394
00:43:46,440 --> 00:43:50,200
 When H is epsilon sparse and has that many vertices or more,

395
00:43:50,200 --> 00:43:54,040
 then H is guaranteed to have an independent set of size K, and you're done.

396
00:43:55,560 --> 00:44:01,960
 So now you are stuck with what happens inside J or the closed neighborhood of S union T.

397
00:44:02,600 --> 00:44:09,960
 And it turns out there, if you have C3 C4 freeness, the only thing you need on top of that

398
00:44:09,960 --> 00:44:14,120
 to guarantee a yes instance is a vertex of degree at least 3K.

399
00:44:14,119 --> 00:44:23,799
 So if you have C3 C4 freeness inside J and the vertex of degree 3K, then again,

400
00:44:23,799 --> 00:44:30,599
 you get a yes instance. So let me prove those two statements separately,

401
00:44:31,319 --> 00:44:38,920
 because they will be basically what we need for the final theorem, for the final kernel.

402
00:44:39,800 --> 00:44:46,760
 So the first lemma, as I told you, if H is epsilon sparse and has more than this many vertices,

403
00:44:46,760 --> 00:44:50,840
 then it's a yes instance, because you have a K-sized independent set in H.

404
00:44:51,559 --> 00:44:58,119
 The idea of this proof is simple. It's a counting argument. And what you need to do basically first

405
00:44:58,119 --> 00:45:04,680
 is to show that H must contain a vertex of degree less than N over K. And then basically,

406
00:45:04,679 --> 00:45:09,799
 you apply the standard greedy packing algorithm for constructing an independent set of size k.

407
00:45:10,359 --> 00:45:16,519
 And the reason you show that and the way you show that H has a vertex of degree less than N over K

408
00:45:16,519 --> 00:45:23,159
 is, again, standard counting argument and the handshaking lemma. So if the minimum degree in

409
00:45:23,159 --> 00:45:28,759
 H was at least N over K, then the number of edges would be at least N squared over 2K,

410
00:45:29,480 --> 00:45:37,000
 which will only happen in an epsilon sparse graph when N is less than or equal to K to the power 1

411
00:45:37,000 --> 00:45:43,160
 over epsilon. And the rest of the proof is basically an induction on K.

412
00:45:45,480 --> 00:45:50,120
 And so that shows you that when you do have an epsilon sparse graph with more than

413
00:45:50,760 --> 00:45:54,200
 this many vertices, then we have a yes instance.

414
00:45:54,200 --> 00:46:03,160
 All right. So how about the second part of the claim? So now what happens if we have a C3 C4

415
00:46:03,160 --> 00:46:10,840
 free J that has a vertex of degree 3K? Well, let's see what happens. So if we have a vertex of degree

416
00:46:10,840 --> 00:46:18,520
 3K, and I'm going to circle it here in yellow. So how can the neighborhood of that vertex look?

417
00:46:18,519 --> 00:46:23,880
 Well, we know that J is C3 free. So the blue edges cannot exist,

418
00:46:23,880 --> 00:46:29,000
 which means that the neighborhood of the yellow vertex is an independent set inside J,

419
00:46:30,840 --> 00:46:37,159
 not in the whole graph. Well, in fact, in the whole, well, no, because we're only talking

420
00:46:37,159 --> 00:46:43,320
 about J as a subgraph here. Right? So the blue edges cannot exist, because otherwise,

421
00:46:43,320 --> 00:46:54,600
 we will get a C3 inside J. All right. So now let's look at the other vertices in S union T.

422
00:46:56,440 --> 00:47:03,000
 The second observation that you need is that any vertex other than the yellow vertex can have at

423
00:47:03,000 --> 00:47:10,360
 most one neighbor in common with the yellow vertex. Because if you do have two neighbors in common,

424
00:47:10,360 --> 00:47:11,640
 then you will get a C4.

425
00:47:15,960 --> 00:47:21,720
 So now what happens if we have 3K vertices in the neighborhood of the yellow vertex? Well,

426
00:47:22,920 --> 00:47:30,039
 at most 2K of them can be connected to some vertex in S union T, and you will get at least

427
00:47:30,039 --> 00:47:37,640
 K of them, some K of them here, that are only connected to the yellow vertex.

428
00:47:38,599 --> 00:47:44,440
 And so now basically, instead of using a buffer inside H, we have just found a buffer inside J,

429
00:47:46,199 --> 00:47:50,920
 and we can use the same strategy. We can jump all the tokens here,

430
00:47:50,920 --> 00:47:55,719
 starting, of course, by the yellow token, and then jump them to where they need to go.

431
00:47:55,720 --> 00:48:05,640
 So now combining those two

432
00:48:08,760 --> 00:48:15,880
 observation lemmas together, if you will, we get the following theorem. So if H is alpha sparse,

433
00:48:15,880 --> 00:48:21,240
 and J is C3, C4 free, then the problem admits a kernel on this many vertices,

434
00:48:22,120 --> 00:48:25,800
 and it's basically a simple application of the previous two lemmas.

435
00:48:25,800 --> 00:48:31,880
 If we have more than this many vertices in H, it's a trivial yes instance. If J has a

436
00:48:31,880 --> 00:48:38,120
 vertex of degree 3K or more, it's a trivial yes instance. And now you combine all of this together.

437
00:48:38,120 --> 00:48:44,360
 We know that S union T is of size at most 2K. We know that the neighborhood of S union T is

438
00:48:44,360 --> 00:48:50,920
 of size at most 2K times 3K, which is roughly 6K squared. And now we know that the rest of the

439
00:48:50,920 --> 00:48:58,200
 graph has at most that many vertices. So basically you sum up those numbers, and you get this bound.

440
00:49:06,440 --> 00:49:12,280
 All right. So how does this theorem imply the result that I promised you to start with?

441
00:49:12,360 --> 00:49:22,040
 So that token jumping and token sliding admit a kernel with order K square vertices,

442
00:49:23,720 --> 00:49:28,840
 I mean, it also holds for bipartite C4 free graphs, right? Obviously because they are C3,

443
00:49:28,840 --> 00:49:37,080
 C4 free. So how do you get the kernel? Well, we know that J cannot contain more than 6K

444
00:49:37,079 --> 00:49:42,599
 squared minus 2K vertices. And we know from another theorem, from another

445
00:49:44,199 --> 00:49:51,639
 paper that C3 free graphs with K squared over log K vertices must have an independent set of size

446
00:49:51,639 --> 00:49:57,480
 at least K. And now we know that if H contains more than this many vertices, then we will get

447
00:49:57,480 --> 00:50:05,719
 the yes instance as well. Right? So it becomes an immediate consequence of the previous theorem.

448
00:50:05,800 --> 00:50:10,120
 But the previous theorem is even more general than this corollary. So this corollary

449
00:50:10,120 --> 00:50:12,680
 does not really use the full power of this theorem.

450
00:50:16,440 --> 00:50:23,240
 All right. That's it. I think I'm on time. If you have questions, I will take them now.

451
00:50:23,240 --> 00:50:35,320
 It was 55 minutes, right? For the talk. I did not go under the time.

452
00:50:35,320 --> 00:50:39,160
 It's fine. We usually allow plus minus 10 minutes. That's all right.

453
00:50:42,440 --> 00:50:45,960
 So I have a question about token sliding. Yes.

454
00:50:46,920 --> 00:50:53,559
 So how crucial, what happens if one does not restrict the independent sets during the

455
00:50:53,559 --> 00:51:01,320
 configuration to be not of the same size? Is that very critical for the difficulty

456
00:51:01,320 --> 00:51:06,280
 or the easiness of the problem? Well, you have to be careful how

457
00:51:06,280 --> 00:51:11,079
 you define that because in token sliding, sliding tokens cannot leave the graph.

458
00:51:11,079 --> 00:51:15,719
 That's correct. But the independent set sequence,

459
00:51:15,719 --> 00:51:18,279
 all the independent sets have to be the same size, right?

460
00:51:19,159 --> 00:51:24,119
 Well, if not some token disappeared at some point and I'm not sure how it disappeared.

461
00:51:26,440 --> 00:51:31,719
 Right? Because you start with something of size K and you're going to something of size K,

462
00:51:31,719 --> 00:51:40,039
 you cannot leave the graph unless you define it in some way. So you will remain of size K throughout.

463
00:51:41,159 --> 00:51:46,119
 But you can become slightly larger than K. But where does the new token come from?

464
00:51:49,079 --> 00:51:53,000
 So there is a third rule that I did not tell you about,

465
00:51:53,000 --> 00:52:00,199
 which is called token addition and removal. Under that rule, we actually allow you to

466
00:52:00,199 --> 00:52:05,639
 remove vertices and add vertices as long as you remain an independent set of size at least K.

467
00:52:05,639 --> 00:52:14,679
 Does that answer your question? Yeah, yeah, yeah, yeah, yeah.

468
00:52:14,679 --> 00:52:22,440
 But in fact, it was shown that this, it was shown that, so addition and removal is

469
00:52:22,440 --> 00:52:26,039
 equivalent to token jumping. I see, I see.

470
00:52:26,039 --> 00:52:30,599
 Right? It doesn't, it never makes sense to add more tokens to your graph if you don't need them.

471
00:52:31,559 --> 00:52:37,400
 You're only making your life harder, intuitively speaking.

472
00:52:41,079 --> 00:52:43,400
 So the other question that I had is, I mean, I heard,

473
00:52:46,679 --> 00:52:54,599
 so is it possible to view this whole problem on an exponential size graph where every vertex

474
00:52:55,239 --> 00:53:03,159
 corresponds to an independent set in the original graph? And then you have edges between

475
00:53:03,159 --> 00:53:07,880
 two vertices if there is an edge between two vertices of the independent set.

476
00:53:07,880 --> 00:53:13,960
 And now you are doing a reachability question. Is that a meaningful way to think about this?

477
00:53:13,960 --> 00:53:19,960
 But that's exactly what we're doing. So the way you define your adjacency, I think,

478
00:53:19,960 --> 00:53:25,079
 so you mean you define, you make two independent sets adjacent if one can be reached from the

479
00:53:25,079 --> 00:53:29,400
 other via a single slide or a single jump. Exactly, yeah, one edge, yeah. There is

480
00:53:29,400 --> 00:53:34,519
 one pair, u and v, which is adjacent. But that's exactly what we're doing.

481
00:53:34,519 --> 00:53:42,039
 OK, OK, yeah. I mean, because we're looking at algorithms here, we kind of forget the

482
00:53:42,039 --> 00:53:47,079
 structural picture behind it. But this algorithm is finding a path in this graph that you're

483
00:53:47,079 --> 00:53:54,039
 describing. Yeah, yeah, that's right. And what we're saying is you can do it in FPT time or not,

484
00:53:54,039 --> 00:54:05,960
 depending on the problem we're talking about. Hi, Amir.

485
00:54:08,759 --> 00:54:16,920
 How are you? Yeah, I'm good. So I have a question. So do the problems remain equally

486
00:54:16,920 --> 00:54:21,240
 hard if we bound the if we have a restriction on the number of times

487
00:54:21,240 --> 00:54:24,680
 we can move the token to a particular vertex?

488
00:54:28,119 --> 00:54:31,880
 The number of times you can move a token to a particular vertex.

489
00:54:33,000 --> 00:54:36,360
 Like the number of times the tokens can be moved to a vertex.

490
00:54:38,360 --> 00:54:44,440
 Well, that's definitely going to change the complexity in at least intuitively speaking,

491
00:54:44,679 --> 00:54:49,800
 because now you're saying maybe it will if you're bounding that by a constant,

492
00:54:49,800 --> 00:54:55,400
 then you might be saying that I'm not allowing exponentially large sequences anymore.

493
00:54:55,400 --> 00:55:00,920
 But in terms of exactly how the complexity changes, I don't have answers. I think it's a

494
00:55:00,920 --> 00:55:09,400
 very nice question to pose. Even in terms of nonparameterized complexity, standard complexity,

495
00:55:09,480 --> 00:55:11,960
 I think that that would be a very interesting question, because

496
00:55:13,240 --> 00:55:17,400
 because it will definitely affect the behavior. I'm not sure exactly how yet.

497
00:55:19,400 --> 00:55:22,680
 I don't know of any results that ask this particular question.

498
00:55:23,880 --> 00:55:29,079
 Okay, so I had one more question in the W-hardness result that you presented.

499
00:55:29,079 --> 00:55:37,079
 So do you know like the length of the the the length of the changes are actually the

500
00:55:37,079 --> 00:55:42,039
 number of changes or flips that you make in your independent set? This is just.

501
00:55:43,000 --> 00:55:49,000
 Yes, yes, yes. We do. So here the number of changes is going to be very it's it's

502
00:55:49,000 --> 00:55:55,319
 basically going to be the shortest possible sequence. So it's it's going to it's it's

503
00:55:55,319 --> 00:55:59,880
 basically going to be so if you think about the simple construction, this one.

504
00:56:00,840 --> 00:56:05,559
 It's basically literally going to be these guys are going to move here. So each is going to cost

505
00:56:05,559 --> 00:56:12,680
 me one slide and then they're all going to and now this guy is going to move here. And now I will pay

506
00:56:12,680 --> 00:56:18,599
 one slide for each one here. Now this is the simplified version of it. Once you go to the

507
00:56:18,599 --> 00:56:23,960
 complete version of it, you have some extra slides within the path, but you can also count those.

508
00:56:23,960 --> 00:56:32,280
 Okay, so but does this mean that so does this mean that at a particular vertex, we're

509
00:56:32,280 --> 00:56:42,039
 placing the token at most once? In this case, yes. Okay. In this case, yes. Okay. So this problem

510
00:56:42,039 --> 00:56:47,400
 should be hard, even if we bound the number of times tokens can be moved to a vertex, right?

511
00:56:47,400 --> 00:56:52,680
 Should be hard, even if we bound the number of times tokens can be moved to a vertex, right?

512
00:56:55,639 --> 00:57:02,680
 Yes. Okay. Yes. So so here in this case, yes. Absolutely. Okay. Thanks.

513
00:57:04,440 --> 00:57:12,920
 So Akanksha, I have a remark about your question. So if a vertex, if a vertex cannot get a token

514
00:57:12,920 --> 00:57:18,119
 twice, then it somehow seems to be selecting disjoint independent sets,

515
00:57:20,760 --> 00:57:25,480
 a sequence of them, and that may have some bearing on coloring, just a top level.

516
00:57:29,880 --> 00:57:35,960
 So actually, for the list, the W harness case that I'm in presented, it is exactly the case,

517
00:57:35,960 --> 00:57:41,320
 right? So we are not allowed to move the token, like twice on the same vertex.

518
00:57:43,240 --> 00:57:49,320
 Yeah. So I didn't get your point of moving. So getting this disjoint independence, it's actually

519
00:57:50,119 --> 00:57:55,159
 because if you say if you think of it from my the way I thought about it, right, that you are

520
00:57:55,159 --> 00:58:00,039
 actually trying to find a path in a large graph where every vertex corresponds to an independent

521
00:58:00,039 --> 00:58:08,280
 set, and you move from one independent set to another. So we can only move from one independent

522
00:58:08,280 --> 00:58:16,600
 set to the other, if the changes is like in case of tokens sliding, it's one probably.

523
00:58:17,400 --> 00:58:17,640
 Yeah.

524
00:58:22,120 --> 00:58:28,519
 So it looks to me that you're asking for a collection of independent sets,

525
00:58:28,519 --> 00:58:33,880
 which are vertex disjoint, if the token sequence of independent sets which are vertex disjoint.

526
00:58:34,840 --> 00:58:41,960
 Yeah. So if I may, I think Akansha's question would be more relevant in a place where we don't

527
00:58:41,960 --> 00:58:48,680
 have a monotone sequence, meaning a sequence. So we need a version of the problem or some cases of

528
00:58:48,680 --> 00:58:55,160
 the problem where a vertex has to be visited multiple times to find solutions. And that is

529
00:58:55,160 --> 00:59:01,800
 known to be the case for some versions or some statements of the problem. And in fact, Akansha,

530
00:59:01,880 --> 00:59:08,360
 so this was the crucial difference between PSPACE completeness and NP completeness of sliding versus

531
00:59:08,360 --> 00:59:15,080
 jumping in bipartite graphs. So it was because we were able to show that no vertex will be visited

532
00:59:15,080 --> 00:59:22,039
 more than once in the other problems. So that's why it's definitely an interesting question to

533
00:59:22,039 --> 00:59:31,720
 pose, but you have to be careful in what context you pose it. I don't know if that kind of settles

534
00:59:32,760 --> 00:59:39,080
 answers your question. Yes, yes, it does. All right. Thanks. You're welcome.

535
00:59:39,079 --> 00:59:50,360
 Any more questions?

536
01:00:09,079 --> 01:00:20,360
 I guess not.

537
01:00:21,239 --> 01:00:27,400
